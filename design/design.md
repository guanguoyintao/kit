# 常见问题

## 1、常见设计模式有哪些

---

好的，遵照您的要求，我们聚焦于经典的 “四人帮” (GoF) 23种设计模式。

我将为您提供每一种模式的详细解释，说明它旨在解决的核心问题，并列举其最典型的应用场景。

---

### 创建型模式 (Creational Patterns)

这类模式的核心在于**将对象的创建过程与使用者解耦**，使得系统在创建什么、如何创建、何时创建等方面更具灵活性。

| 设计模式 | 核心思想 | 解决什么问题？ | 典型应用场景 |
| :--- | :--- | :--- | :--- |
| **1. 单例模式 (Singleton)** | 保证一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点来获取这个唯一的实例。 | **问题：** 如何确保一个类（如配置管理器、数据库连接池）在整个应用程序中只有一个实例，以避免状态不一致、资源浪费或重复初始化？直接使用全局变量无法防止被意外地多次实例化。 | 1. **全局配置类：** 整个应用读取同一份配置信息。<br>2. **数据库连接池：** 所有数据库操作共享一个连接池，避免频繁创建和销毁连接的开销。<br>3. **日志记录器 (Logger)：** 所有模块的日志都通过同一个实例写入到同一个目标（文件、控制台等）。<br>4. **线程池：** 统一管理和复用线程资源。 |
| **2. 工厂方法模式 (Factory Method)** | 定义一个用于创建对象的接口（工厂方法），但将实际的实例化决策延迟到子类中。父类只知道如何使用产品，而子类决定具体创建哪种产品。 | **问题：** 当一个类需要创建某个接口的对象，但无法预知到底要创建哪个具体实现类的实例时。如果用 `if-else` 或 `switch` 来硬编码创建逻辑，会导致代码僵化，难以扩展。 | 1. **多格式文档应用：** `Application` 类有 `createDocument()` 方法，`WordApplication` 子类重写它来创建 `WordDocument`，`PdfApplication` 子类则创建 `PdfDocument`。<br>2. **多数据源连接：** 定义一个 `DBConnectionFactory` 接口，可以有 `MySQLFactory`、`OracleFactory` 等实现，分别创建对应的数据库连接对象。<br>3. **日志框架：** 用户可以配置使用文件日志或数据库日志，框架通过不同的工厂子类来创建对应的 `Logger` 实例。 |
| **3. 抽象工厂模式 (Abstract Factory)** | 提供一个接口，用于创建**一系列相关或相互依赖的对象（一个产品族）**，而无需指定它们具体的类。 | **问题：** 如何创建一组必须相互兼容、协同工作的对象？例如，UI库需要一套风格统一的组件（按钮、文本框、窗口）。如果混用不同风格的组件，界面会非常混乱。你需要一种机制能轻松地切换整个产品族。 | 1. **跨平台UI库：** `GUIFactory` 接口定义 `createButton()` 和 `createCheckbox()`。`WindowsFactory` 创建Windows风格的按钮和复选框，`MacFactory` 创建macOS风格的。<br>2. **更换数据库：** `DAOFactory` 接口定义 `createUserDAO()` 和 `createOrderDAO()`。`SQLServerFactory` 和 `OracleFactory` 分别创建针对特定数据库的DAO对象。<br>3. **游戏皮肤更换：** 一个抽象工厂负责创建一套特定主题的英雄、小兵和建筑皮肤。 |
| **4. 生成器模式 (Builder)** | 将一个复杂对象的构建过程与其最终表示分离，使得同样的构建过程可以创建出不同的表示。它允许你分步骤、选择性地构建对象。 | **问题：** 当一个对象的构造函数参数过多（“伸缩构造函数”问题），或者对象的创建过程非常复杂、包含多个步骤和可选部分时。直接使用构造函数会导致代码臃肿且难以阅读，也无法保证对象在构建完成前处于一致的状态。 | 1. **构建复杂的查询语句：** 如SQL的 `QueryBuilder`，可以链式调用 `.select()`, `.where()`, `.orderBy()` 等方法分步构建查询。<br>2. **创建复杂的HTTP请求：** `RequestBuilder` 可以让你设置URL、请求方法、头部、请求体等。<br>3. **`StringBuilder` / `StringBuffer`：** Java中用于构建字符串，避免了 `String` 的不可变性导致的性能问题。<br>4. **Lombok的 `@Builder` 注解：** 自动为类生成生成器模式的代码。 |
| **5. 原型模式 (Prototype)** | 使用一个已创建的实例（原型）作为模板，通过复制（克隆）这个原型来创建新的对象。 | **问题：** 当创建一个对象的成本非常高（例如，需要复杂的计算、数据库查询或网络IO）时，或者需要创建大量相似对象时。每次都通过 `new` 来创建会非常低效。 | 1. **游戏开发：** 在屏幕上生成大量相似的敌人或粒子效果，通过克隆一个“敌人原型”来快速创建。<br>2. **缓存实现：** 从缓存中获取一个预先计算好的对象，然后克隆一份返回给调用者，防止原始缓存对象被修改。<br>3. **复杂对象的默认配置：** 创建一个配置复杂的对象作为原型，后续创建新对象时都从这个原型克隆，再进行微调。 |

---

### 结构型模式 (Structural Patterns)

这类模式的核心在于**如何将类或对象组合成更大的、更灵活的结构**。

| 设计模式 | 核心思想 | 解决什么问题？ | 典型应用场景 |
| :--- | :--- | :--- | :--- |
| **6. 适配器模式 (Adapter)** | 将一个类的接口转换成客户端所期待的另一个接口。它使得原本接口不兼容的类可以协同工作。 | **问题：** 你想使用一个已经存在的、功能强大的类，但它的接口与你当前系统的接口规范不匹配。你不能或不想修改这个已有的类。 | 1. **集成第三方库：** 一个新的日志框架接口与项目中正在使用的旧日志库接口不兼容，创建一个适配器来封装旧库。<br>2. **兼容遗留系统：** 新系统需要调用旧系统提供的数据接口，但接口格式（如XML vs JSON）不同，适配器负责转换。<br>3. **Java中的 `Arrays.asList()`：** 它将一个数组适配成一个 `List` 接口。 |
| **7. 桥接模式 (Bridge)** | 将**抽象部分**与它的**实现部分**分离，使它们都可以独立地变化。它用组合关系替代继承关系来解决多维度变化的问题。 | **问题：** 当一个类存在两个或多个独立变化的维度时，如果使用继承，会导致子类数量呈爆炸性增长（笛卡尔积）。例如，“形状”有圆形、方形，“颜色”有红、蓝，就会产生`RedCircle`, `BlueCircle`, `RedSquare`, `BlueSquare`。 | 1. **跨平台GUI开发：** 将“窗口”这个抽象（如`DialogWindow`, `NotificationWindow`）与其在不同操作系统上的实现（`WindowsImpl`, `LinuxImpl`）分离。<br>2. **不同数据库的驱动程序：** JDBC（Java数据库连接）就是一个桥接模式。`DriverManager` 是桥梁，各种数据库厂商提供自己的驱动实现。<br>3. **遥控器与设备：** “遥控器”的抽象（`BasicRemote`, `AdvancedRemote`）可以独立于它控制的“设备”实现（`TV`, `Radio`）进行变化。 |
| **8. 组合模式 (Composite)** | 将对象组合成树形结构，以表示“部分-整体”的层次关系。它使得客户端可以统一地处理单个对象（叶子节点）和组合对象（容器节点）。 | **问题：** 如何处理具有层级结构的数据，并让客户端代码无需区分它正在处理的是一个单独的元素还是一个元素的集合？ | 1. **文件系统：** `文件`（叶子）和`文件夹`（容器）都实现了同一个接口（如`FileSystemNode`），都有如`getName()`、`getSize()`等方法。<br>2. **图形用户界面（GUI）：** 一个`按钮`（叶子）和一个`面板`（容器，可以包含多个按钮或其他面板）都可以被统一地绘制（`draw()`）或处理事件。<br>3. **公司组织架构：** `员工`（叶子）和`部门`（容器）都可以计算薪资总额。 |
| **9. 装饰器模式 (Decorator)** | 动态地、透明地给一个对象添加一些额外的职责或功能，同时又不改变其结构。就增加功能而言，它比生成子类更为灵活。 | **问题：** 你想为一个对象扩展功能，但又不想通过创建大量子类的方式来实现，因为这会导致类的数量激增且是静态的。你需要一种在运行时动态添加功能的方法。 | 1. **Java I/O流：** `FileInputStream` 是基础组件，可以用 `BufferedInputStream` (增加缓冲功能)、`GZIPInputStream` (增加解压功能) 来层层包装它。<br>2. **UI组件添加滚动条或边框：** 一个`TextView` 组件可以被 `ScrollBarDecorator` 包装来添加滚动条功能。<br>3. **权限控制：** 一个核心操作对象可以被一个`PermissionDecorator` 包装，在执行核心操作前进行权限检查。 |
| **10. 门面模式 (Facade)** | 为一个复杂的子系统提供一个简化的、统一的高层接口。它隐藏了子系统的复杂性，使得子系统更容易被使用。 | **问题：** 一个系统非常复杂，由许多相互关联的类和模块组成。客户端如果直接与这些底层模块交互，会非常困难且耦合度高。 | 1. **一键观影：** 家庭影院系统由投影仪、DVD播放器、音响、灯光等多个子系统组成。一个`HomeTheaterFacade` 提供 `watchMovie()` 方法，内部会依次调用各个子系统的相应方法。<br>2. **启动电脑：** 按下电源按钮（门面方法），内部触发了CPU、内存、硬盘、显卡等一系列复杂的自检和启动过程。<br>3. **大部分库和框架的API：** 它们都提供了一些简单的入口类或函数，封装了内部复杂的实现逻辑。 |
| **11. 享元模式 (Flyweight)** | 运用共享技术来有效地支持大量细粒度的对象。它将对象的状态分为内部状态（可共享）和外部状态（不可共享），从而减少内存消耗。 | **问题：** 当一个应用程序需要创建大量相似的对象，导致内存占用过高，甚至内存溢出时。这些对象大部分状态是可以共享的。 | 1. **文本编辑器中的字符：** 一个字符的字形（如'A'）是内部状态，可以被所有'A'共享。而它的位置、颜色是外部状态，由客户端传入。<br>2. **围棋或象棋游戏：** 棋子的颜色和类型是内部状态（黑方“车”、白方“马”），可以共享。棋子在棋盘上的位置是外部状态。<br>3. **数据库连接池：** 连接对象本身就是享元，它们被多个客户端共享使用。 |
| **12. 代理模式 (Proxy)** | 为其他对象提供一种代理或占位符，以控制对这个对象的访问。 | **问题：** 你需要控制对一个对象的访问，或者在访问该对象前后执行一些额外的操作，但又不想直接修改这个对象。 | 1. **虚拟代理 (Virtual Proxy)：** 延迟加载。例如，一个图片代理对象，只有当图片真正需要显示时，才去加载真实的大图对象。<br>2. **保护代理 (Protection Proxy)：** 访问控制。根据调用者的权限，决定是否允许其调用真实对象的方法。<br>3. **远程代理 (Remote Proxy)：** 为一个位于不同地址空间（如另一台服务器）的对象提供一个本地的代表。RPC（远程过程调用）框架的核心。<br>4. **日志/缓存代理：** 在调用真实方法前后记录日志或检查缓存。 |

---

### 行为型模式 (Behavioral Patterns)

这类模式的核心在于**识别对象之间常见的通信模式，并实现这些模式**，从而提高灵活性、减少耦合。

| 设计模式 | 核心思想 | 解决什么问题？ | 典型应用场景 |
| :--- | :--- | :--- | :--- |
| **13. 责任链模式 (Chain of Responsibility)** | 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 | **问题：** 一个请求可能需要由多个对象中的某一个来处理，但具体是哪一个在运行时才能确定。你不想让请求发送方和一大堆可能的接收方硬编码耦合。 | 1. **Web框架的中间件 (Middleware)：** 一个HTTP请求依次通过日志、认证、授权、缓存等中间件，每个中间件都可以处理请求或将其传递给下一个。<br>2. **多级审批流程：** 一个采购申请首先由小组长审批，如果金额超过权限，则传递给部门经理，再到总监。<br>3. **GUI中的事件冒泡：** 点击一个按钮，事件先由按钮处理，如果按钮不处理，则传递给它的父容器处理，以此类推。 |
| **14. 命令模式 (Command)** | 将一个请求（操作）封装成一个独立的对象。这使得你可以用不同的请求来参数化其他对象，或者对请求进行排队、记录日志、以及支持可撤销的操作。 | **问题：** 需要将操作的请求者与操作的执行者解耦。或者需要支持撤销、重做、排队、宏命令（一组命令）等功能。 | 1. **图形界面的按钮：** 按钮（请求者）不直接执行业务逻辑，而是持有一个命令对象。点击时，调用命令的 `execute()` 方法。<br>2. **文本编辑器的撤销/重做：** 将用户的每一次操作（输入、删除）封装成命令对象，并存入历史栈中。<br>3. **任务队列系统：** 将需要异步执行的任务封装成命令对象，放入队列中，由工作线程取出并执行。 |
| **15. 解释器模式 (Interpreter)** | 给定一种语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。 | **问题：** 当有一个特定领域的问题，可以被表示为一种简单的语言时，使用该模式可以方便地解释和执行这种语言。 | 1. **正则表达式引擎：** `.`、`*`、`[]` 等都是语言的文法，引擎负责解释这个文法来匹配字符串。<br>2. **SQL解析器：** 解析 `SELECT * FROM users WHERE id = 1` 这样的SQL语句，并将其转换为数据库可以执行的操作。<br>3. **各种模板引擎：** 如Thymeleaf、FreeMarker，它们解释模板中的特定语法（如 `${user.name}`）并替换为实际数据。 |
| **16. 迭代器模式 (Iterator)** | 提供一种方法来顺序访问一个聚合对象（如列表、集合）中的各个元素，而又不需要暴露该对象的内部表示。 | **问题：** 如何在不暴露一个集合内部复杂结构（如数组、链表、树）的前提下，为客户端提供一个统一的遍历方式？ | 1. **所有编程语言中的集合遍历：** Java的 `Iterator` 接口、Go的 `for...range`、Python的 `for...in` 都是迭代器模式的体现。<br>2. **数据库查询结果集 (ResultSet)：** 你可以通过 `.next()` 方法逐行遍历查询结果，而无需关心数据在底层是如何存储和传输的。 |
| **17. 中介者模式 (Mediator)** | 用一个中介对象来封装一系列对象之间的交互。中介者使得各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 | **问题：** 当系统中对象之间存在复杂的网状通信结构（多对多关系）时，每个对象都需要维护对其他多个对象的引用，导致系统耦合度极高，难以维护。 | 1. **聊天室：** 所有用户（Colleague）都只和聊天室服务器（Mediator）通信，由服务器负责将消息转发给其他用户，用户之间不直接通信。<br>2. **GUI中的对话框：** 对话框（Mediator）协调其内部各个组件（按钮、文本框、列表）之间的交互。例如，当列表选中某项时，对话框会启用“删除”按钮。<br>3. **机场塔台：** 塔台（Mediator）统一指挥所有飞机（Colleague）的起飞和降落，飞机之间不直接通信协调。 |
| **18. 备忘录模式 (Memento)** | 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。 | **问题：** 如何实现对象的快照和回滚功能（如撤销操作），同时又不想暴露对象的内部实现细节？ | 1. **文本编辑器或绘图软件的撤销/重做：** 每执行一个操作，就将当前文档或画布的状态保存为一个备忘录对象。<br>2. **游戏存档/读档：** 游戏主角的状态（生命、魔法、位置、物品）被保存到一个备忘录对象中，即存档文件。<br>3. **数据库事务的回滚 (Rollback)：** 在事务开始时创建一个状态快照（备忘录），如果事务失败，则用这个快照来恢复数据。 |
| **19. 观察者模式 (Observer)** | 定义对象之间一种一对多的依赖关系，当一个对象（主题/被观察者）的状态发生改变时，所有依赖于它的对象（观察者）都得到通知并被自动更新。 | **问题：** 当一个对象的状态变化需要通知其他多个对象，并且你不想让这个对象与那些需要被通知的对象紧密耦合时。 | 1. **GUI事件监听：** 按钮（被观察者）被点击时，会通知所有注册的事件监听器（观察者）。<br>2. **发布/订阅 (Pub/Sub) 模型：** 消息队列中的生产者发布消息到一个主题（Subject），所有订阅了该主题的消费者（Observer）都会收到消息。<br>3. **MVC/MVVM架构：** 模型（Model）作为被观察者，当其数据变化时，会通知视图（View）或视图模型（ViewModel）进行更新。 |
| **20. 状态模式 (State)** | 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 | **问题：** 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。如果使用大量的 `if-else` 或 `switch` 语句来判断状态，代码会变得非常复杂和难以维护。 | 1. **订单系统：** 一个 `Order` 对象有“待支付”、“已支付”、“已发货”、“已完成”等状态。在不同状态下，`pay()`、`cancel()`、`ship()` 等方法的行为是完全不同的。<br>2. **网络连接：** 一个 `Connection` 对象有“未连接”、“连接中”、“已连接”、“已关闭”等状态，其 `connect()`、`send()`、`close()` 等行为随状态而变。<br>3. **自动售货机：** 根据当前状态（有货/无货、已投币/未投币），对用户的操作（投币、选择商品）做出不同的响应。 |
| **21. 策略模式 (Strategy)** | 定义一系列算法，将每一个算法封装起来，并使它们可以相互替换。策略模式使得算法可独立于使用它的客户而变化。 | **问题：** 当解决同一个问题有多种不同的算法或策略，并且需要在运行时根据不同情况选择使用哪一种时。如果用 `if-else` 来选择，会违反开闭原则。 | 1. **支付系统：** 一个订单支付时，可以选择不同的支付策略，如 `AlipayStrategy`, `WeChatPayStrategy`, `CreditCardStrategy`。<br>2. **排序功能：** 可以根据数据量的大小和特性，动态选择使用快速排序、归并排序或冒泡排序策略。<br>3. **出行路线规划：** 用户可以选择“最短时间”、“最少换乘”或“步行最少”等不同的路线规划策略。 |
| **22. 模板方法模式 (Template Method)** | 在一个抽象类中定义一个操作中的算法的骨架（模板方法），而将一些可变的步骤延迟到子类中去实现。 | **问题：** 当多个子类有共同的、固定的执行流程或算法结构，但其中某些步骤的具体实现又各不相同时。你想避免在每个子类中重复编写相同的流程代码。 | 1. **泡茶和泡咖啡：** 制作流程骨架是“烧水 -> 冲泡 -> 倒入杯中 -> 加料”。`泡茶`和`泡咖啡`子类分别实现“冲泡”（茶叶/咖啡粉）和“加料”（柠檬/糖和牛奶）这两个可变步骤。<br>2. **框架的生命周期方法：** Web框架中的请求处理、测试框架中的 `setUp()` 和 `tearDown()`，都定义了固定的执行流程，用户只需在特定的“钩子”方法中填充自己的逻辑。<br>3. **各种数据处理ETL流程：** 定义一个“提取-转换-加载”的模板方法，具体的提取、转换、加载逻辑由子类实现。 |
| **23. 访问者模式 (Visitor)** | 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下，为这些元素定义新的操作。 | **问题：** 你需要对一个复杂的对象结构（如树）中的不同类型的节点执行不同的操作。如果把这些操作直接添加到节点类中，会污染节点类，且不易于增加新的操作。 | 1. **编译器中的抽象语法树（AST）：** 你可能需要对AST进行多种操作，如类型检查、代码生成、语法高亮。每种操作都可以实现为一个访问者，去“访问”AST中的各种节点（变量声明、函数调用等）。<br>2. **文档处理：** 一个文档由段落、图片、表格等多种元素组成。你可以定义一个`ExportVisitor`来将整个文档导出为HTML，再定义一个`WordCountVisitor`来统计字数，而无需修改`段落`、`图片`等元素类。 |

## 2、设计原则有哪些

---

### 1. 开闭原则 (Open Closed Principle, OCP)

这是最核心、最重要的设计原则。

| | |
| :--- | :--- |
| **原则说明** | **一个软件实体（如类、模块、函数）应该对扩展开放，对修改关闭 (Software entities should be open for extension, but closed for modification)。**<br><br>核心思想是，当需要增加新功能时，我们应该通过**增加新的代码**（如实现新的子类或模块）来完成，而不是去**修改已经存在的、经过测试的代码**。这通常需要通过抽象（接口、抽象类）来实现。 |
| **必须遵循的场景** | 1. **当软件的核心功能频繁变化或扩展时：** 比如一个数据导出工具，最初只支持导出为CSV，但未来可能需要支持XML, JSON, PDF等。如果每次都修改核心导出类，代码会变得混乱不堪。<br>2. **设计框架或库供他人使用时：** 框架的设计者无法预知使用者会如何扩展。必须提供清晰的扩展点（接口、抽象类），而核心流程代码必须是稳定、不可修改的。<br>3. **业务流程有多种处理策略时：** 例如一个电商系统的优惠计算，可能有满减、折扣、优惠券等多种策略。未来还会增加新的优惠活动，此时必须遵循开闭原则。 |
| **不遵循的后果** | **维护的噩梦和系统的不稳定。**<br>1. **引入缺陷（Bug）：** 修改已经上线的、稳定的代码，无论多么小心，都有可能引入新的Bug，影响原有功能。<br>2. **影响范围不可控：** 一个看似简单的修改，可能会像蝴蝶效应一样，影响到系统的其他部分，导致回归测试的成本急剧增加。<br>3. **代码越来越复杂：** 不断的修改会导致原有类中出现大量的 `if-else` 或 `switch-case` 分支，代码变得臃肿、难以理解和维护。 |

### 2. 单一职责原则 (Single Responsibility Principle, SRP)

| | |
| :--- | :--- |
| **原则说明** | **一个类或模块应该有且只有一个引起它变化的原因 (There should never be more than one reason for a class to change)。**<br><br>通俗地说，一个类只应该负责一项职责。如果一个类承担了多个职责，那么这些职责的变化都可能导致这个类的修改，从而增加了类被破坏的风险。 |
| **必须遵循的场景** | 1. **当一个类的不同功能由不同的角色或团队负责变更时：** 例如，一个 `Employee` 类，其中包含了计算薪酬的逻辑（由财务部门决定）和保存到数据库的逻辑（由DBA团队决定）。如果这两个职责混在一起，DBA修改数据库结构可能会影响到薪酬计算的正确性。<br>2. **当类的某个职责需要被复用，而其他职责不需要时：** 比如一个类既负责数据校验，又负责数据格式化。在另一个场景中，你可能只需要数据校验功能，但却被迫引入了不需要的格式化功能。<br>3. **类的代码量变得巨大，难以理解和测试时：** 一个庞大的“上帝类”（God Class）通常违反了单一职责原则，它什么都干，导致任何小修改都变得困难重重。 |
| **不遵循的后果** | **高耦合和低内聚，导致系统脆弱、难以维护。**<br>1. **职责扩散：** 一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。例如，修改了报表生成的逻辑，却意外地导致了数据持久化失败。<br>2. **复用性差：** 因为类包含了多个职责，你无法在不引入其他无关职责的情况下复用其中一个职责。<br>3. **测试困难：** 测试一个职责时，需要为其依赖的其他职责准备测试环境，导致单元测试变得复杂。 |

### 3. 里氏代换原则 (Liskov Substitution Principle, LSP)

| | |
| :--- | :--- |
| **原则说明** | **所有引用基类（父类）的地方必须能透明地使用其子类的对象 (Subtypes must be substitutable for their base types)。**<br><br>简单来说，子类对象能够替换父类对象，并且程序的逻辑行为不发生改变。子类可以有自己的个性，但不能违背父类的约定（契约）。这意味着子类重写父类方法时，输入参数要更宽松，输出结果要更严格，不能抛出父类没有的异常。 |
| **必须遵循的场景** | **任何使用继承和多态的场景都必须严格遵循此原则。**<br>1. **当使用一个父类或接口类型的集合来存储各种子类对象时：** 例如 `List<Shape> shapes`，你遍历这个列表并调用 `shape.draw()` 方法，你期望每个子类（`Circle`, `Square`）都能正确地绘制自己，而不是抛出异常或做出怪异的行为。<br>2. **当方法的参数是父类类型时：** 一个方法 `calculateArea(Shape s)`，它必须能够处理任何传入的 `Shape` 子类对象，而不需要在方法内部用 `if (s instanceof Square)` 这样的代码来做特殊处理。 |
| **不遵循的后果** | **继承体系的滥用，导致多态失效和逻辑混乱。**<br>1. **运行时错误：** 如果子类违背了父类的约定（例如，重写方法时抛出了新的异常），那么在使用父类引用的地方调用该方法时，程序可能会因为未捕获的异常而崩溃。<br>2. **破坏开闭原则：** 客户端代码将被迫加入大量的 `if/else` 或 `instanceof` 判断来识别具体的子类类型，以便进行特殊处理。这使得系统在增加新子类时，必须修改所有这些判断逻辑。<br>3. **逻辑行为不可预测：** 著名的例子是“正方形不是长方形”。如果 `Square` 继承自 `Rectangle`，并重写了 `setWidth` 方法使其同时改变 `height`，这就违背了 `Rectangle` 的“长宽可以独立变化”的约定，导致使用 `Rectangle` 引用的代码出现非预期的结果。 |

### 4. 依赖倒转原则 (Dependency Inversion Principle, DIP)

| | |
| :--- | :--- |
| **原则说明** | **高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象 (High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions)。**<br><br>核心思想是**面向接口编程**，而不是面向实现编程。通过抽象（接口或抽象类）来隔离高层业务逻辑和低层具体实现，实现两者之间的解耦。 |
| **必须遵循的场景** | 1. **当底层实现需要频繁变化或替换时：** 例如，一个应用的数据存储方式可能从MySQL切换到PostgreSQL，或者从文件系统切换到云存储。如果业务逻辑层直接依赖具体的MySQL实现类，那么每次切换都需要修改大量的业务代码。<br>2. **当需要对业务逻辑进行单元测试时：** 如果业务逻辑直接依赖于具体的数据库或网络组件，那么测试它就变得非常困难。通过依赖倒转，我们可以在测试时轻松地传入一个模拟的（Mock）实现，从而隔离测试环境。<br>3. **构建可插拔的系统或框架时：** 框架定义了稳定的抽象接口（扩展点），而具体的插件则是对这些接口的实现。这使得系统可以灵活地组合和替换功能模块。 |
| **不遵循的后果** | **系统僵化、脆弱且难以测试。**<br>1. **紧密耦合：** 高层业务逻辑与底层实现细节紧密地绑定在一起，任何底层的改动都可能直接影响到高层，导致“牵一发而动全身”。<br>2. **可测试性差：** 无法对高层模块进行独立的单元测试，只能进行成本高昂的集成测试。<br>3. **复用性低：** 因为高层模块依赖于特定的底层实现，所以它很难被复用到其他具有不同底层实现的环境中。 |

### 5. 接口隔离原则 (Interface Segregation Principle, ISP)

| | |
| :--- | :--- |
| **原则说明** | **客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上 (Clients should not be forced to depend upon interfaces that they do not use)。**<br><br>这个原则旨在解决“胖接口”（Fat Interface）的问题。应该将庞大、臃肿的接口拆分成更小、更具体的接口，让客户端只依赖于它们真正需要的方法。 |
| **必须遵循的场景** | 1. **当一个接口拥有大量方法，但不同的客户端只关心其中的一部分时：** 例如，一个庞大的 `IUserService` 接口，既有给普通用户用的 `login()`, `register()` 方法，也有给管理员用的 `banUser()`, `resetPassword()` 方法。普通用户客户端不应该知道管理员方法的签名。<br>2. **当接口的实现类因为某些原因无法实现接口中的所有方法时：** 例如，一个 `ISmartDevice` 接口有 `call()` 和 `takePhoto()` 方法。`SmartPhone` 类可以全部实现，但 `SmartWatch` 类可能无法实现 `takePhoto()`，只能提供一个空实现或抛出异常，这是糟糕的设计。 |
| **不遵循的后果** | **不必要的耦合和设计僵化。**<br>1. **强制依赖：** 客户端被迫依赖于它用不到的方法。当这些用不到的方法签名发生变化时，即使客户端的功能没有变化，也需要重新编译和测试。<br>2. **接口污染：** 接口的意图变得不清晰。实现类可能需要实现一些对它来说毫无意义的方法，这是一种“接口污染”。<br>3. **破坏里氏代换原则：** 如果一个类为了实现一个胖接口而对某些方法提供空实现或抛出 `UnsupportedOperationException`，那么它就不能安全地被其接口类型引用，违反了LSP。 |

### 6. 合成/聚合复用原则 (Composite/Aggregate Reuse Principle, CARP)

| | |
| :--- | :--- |
| **原则说明** | **尽量使用对象组合（Composition/Aggregation），而不是继承来达到复用的目的 (Favor composition over inheritance)。**<br><br>继承（“Is-A”关系）是一种强耦合关系，父类的任何变化都会影响到所有子类。而组合/聚合（“Has-A”关系）则是将一个对象作为另一个对象的成员变量，是一种更松散的耦合关系。 |
| **必须遵循的场景** | 1. **当你想复用一个类的功能，但这两个类之间不构成严格的“Is-A”关系时：** 例如，`Bird` 和 `Plane` 都能飞（`fly()`），但让 `Plane` 继承 `Bird` 显然是荒谬的。正确的做法是创建一个 `Flyable` 接口或 `Engine` 类，让 `Bird` 和 `Plane` 都去组合（拥有）这个飞行的能力。<br>2. **当需要动态地改变或组合类的行为时：** 使用组合，可以在运行时动态地替换掉被组合的对象，从而改变宿主对象的行为。这是策略模式和装饰器模式的基础。而继承关系在编译时就已经确定，是静态的。<br>3. **当你想避免“继承爆炸”时：** 如果一个系统有多个维度的变化，使用继承会导致类的数量急剧增加。 |
| **不遵循的后果** | **系统脆弱、不灵活。**<br>1. **“白箱”复用：** 继承是“白箱”复用，父类的实现细节对子类是可见的，子类可能会无意中破坏父类的内部状态，导致封装性被破坏。<br>2. **高耦合：** 子类与父类紧密耦合，父类的任何变更都可能导致子类需要修改，甚至编译失败。<br>3. **灵活性差：** 无法在运行时改变继承关系。一旦一个类继承了另一个类，这种关系就固定了。 |

### 7. 迪米特法则 (Law of Demeter, LoD) / 最少知识原则 (LKP)

| | |
| :--- | :--- |
| **原则说明** | **一个对象应该对其他对象保持最少的了解 (Each unit should have only limited knowledge about other units: only units "closely" related to the current unit)。**<br><br>通俗地讲，一个类只应该和它的“直接朋友”交谈，不应该和“陌生人”说话。 “直接朋友”包括：当前对象的成员变量、方法的参数、方法内部创建的对象。要避免出现 `a.getB().getC().doSomething()` 这样的长调用链。 |
| **必须遵循的场景** | 1. **在设计模块或类的公开API时：** 应该尽量隐藏内部的实现结构。如果一个方法返回了一个内部对象，调用者就可以通过这个对象深入到模块的内部，这破坏了封装。<br>2. **当系统中的类之间存在复杂的依赖关系网时：** 遵循迪米特法则可以有效地减少类之间的耦合度，使得修改一个类不会波及到太多其他不相关的类。<br>3. **进行重构以提高系统可维护性时：** 看到一长串的点（`.`）调用，通常就是违反迪米特法则的信号，也是重构的目标。 |
| **不遵循的后果** | **高度耦合的系统，难以维护和变更。**<br>1. **级联修改：** 一个类的内部结构变化（例如 `B` 类不再有 `getC()` 方法），会导致所有通过 `a.getB().getC()` 访问它的遥远客户端代码全部需要修改。<br>2. **封装性被破坏：** 客户端代码知道了太多不该知道的内部实现细节，这使得类的内部结构难以自由地进行重构和优化。<br>3. **可测试性降低：** 为了测试一个方法，你需要模拟（Mock）出一整条调用链上的所有对象，这会让测试变得非常复杂。 |

## 3、什么是函数编程，函数式变成常见算子有哪些

---

#### 核心原则与要求

| 原则/要求 | 技术定义 | 必须遵循的场景 (Why it's critical) |
| :--- | :--- | :--- |
| **1. 纯函数 (Pure Functions)** | 一个函数必须同时满足：<br>1. **引用透明：** 相同的输入，永远产生相同的输出。<br>2. **无副作用：** 不修改函数作用域之外的任何状态（不改全局变量、不改入参、无I/O）。 | **单元测试与调试：** 当你需要编写可预测、易于隔离测试的业务逻辑时。纯函数不需要复杂的 Mock 和环境搭建，其行为完全由输入决定。<br>**并发编程：** 在多线程/多协程环境中，对共享数据进行计算时。纯函数天生线程安全，无需加锁。 |
| **2. 不可变性 (Immutability)** | 数据结构一旦创建，其内部状态就不能再被改变。任何修改操作都必须返回一个新的数据结构副本。 | **状态管理框架 (如 Redux/Vuex)：** 当你需要追踪应用状态的每一次变更，并轻松实现撤销/重做（时间旅行调试）功能时。<br>**多线程数据共享：** 当一个复杂的数据对象（如配置信息）需要在多个线程间安全共享时，不可变性杜绝了数据被意外篡改的风险。 |
| **3. 函数是一等公民 (First-Class Functions)** | 函数可以像 `int`, `string` 等类型一样，被赋值给变量、存入数组、作为参数传递、作为函数返回值。 | **行为参数化：** 当你需要编写一个通用算法，但其部分行为需要由调用者决定时。最经典的场景是 `sort` 函数，它接受一个自定义的 `compare` 函数作为参数。<br>**回调函数：** 在处理异步操作（如网络请求、定时器）时，你需要传递一个函数，以便在操作完成时被调用。 |

#### 核心技术与编程模式

| 技术/模式 | 技术定义 | 典型编程场景 (When to use it) |
| :--- | :--- | :--- |
| **1. 高阶函数 (Higher-Order Functions)** | 接受函数为参数，或返回一个函数的函数。 | **抽象通用操作：** 当你发现自己在不同地方重复编写类似的循环逻辑时。例如，用 `map`, `filter`, `reduce` 来替代手写的 `for` 循环，使代码更具声明性。<br>**创建可配置的函数：** 编写一个函数，其部分行为由传入的另一个函数来定义。例如，一个通用的事件监听器，它接受一个具体的事件处理函数。 |
| **2. 柯里化 (Currying)** | 将一个多参数函数 `f(a, b, c)` 转换为一个单参数函数链 `f'(a)(b)(c)`。 | **创建专用工具函数：** 当你需要基于一个通用函数，通过预设部分参数来创建一系列功能更具体的函数时。<br>**场景示例：** 你有一个通用函数 `request(method, url, data)`。通过柯里化，你可以轻松创建 `const post = request('POST')`，然后进一步创建 `const postToUsers = post('/api/users')`。 |
| **3. 偏函数应用 (Partial Application)** | 固定一个多参数函数的部分参数，生成一个参数更少的新函数 `g(b, c) = f(1, b, c)`。 | **简化重复调用：** 当你发现自己在代码中反复以相同的几个参数调用同一个函数时。<br>**场景示例：** 你有一个 `add(a, b)` 函数。如果你在代码中大量进行 `add(10, x)`, `add(10, y)` 的操作，就可以创建一个偏函数 `const add10 = partial(add, 10)`，然后调用 `add10(x)`, `add10(y)`，使意图更清晰。 |
| **4. 函数组合 (Function Composition)** | 将多个函数 `f` 和 `g` 组合成一个新的函数，使得 `compose(f, g)(x)` 等价于 `f(g(x))`。 | **构建数据处理流水线 (Pipeline)：** 当一个数据需要经过一系列连续、独立的转换步骤时。<br>**场景示例：** 处理用户输入。你需要 `1. trim` (去除首尾空格) -> `2. sanitize` (过滤非法字符) -> `3. validate` (验证格式)。使用函数组合，你可以创建一个 `const processInput = compose(validate, sanitize, trim)`，然后直接调用 `processInput(userInput)`。 |
| **5. Point-Free 风格 (Tacit Programming)** | 通过组合函数来构建新函数，而代码中完全不出现需要处理的数据参数。 | **追求代码的极致简洁和高层抽象：** 当你想让代码读起来更像业务逻辑的自然语言描述，而不是底层的操作指令时。<br>**场景示例：** 获取一组用户的激活用户名称。非 Point-Free: `users => users.filter(u => u.active).map(u => u.name)`。Point-Free: `compose(map(prop('name')), filter(prop('active')))`。 |
| **6. 递归 (Recursion)** | 函数调用自身。 | **处理嵌套或层级结构的数据：** 这是递归最核心的应用场景。<br>1.  **文件系统遍历：** 遍历一个目录及其所有子目录。<br>2.  **DOM/AST 遍历：** 处理网页元素树或代码语法树。<br>3.  **解析 JSON/XML：** 处理深度嵌套的数据结构。 |

#### 高级抽象与数据结构

| 抽象/数据结构 | 技术定义 | 典型编程场景 (When to use it) |
| :--- | :--- | :--- |
| **1. 代数数据类型 (ADT)** | **和类型 (Sum Type):** 一个值是多种可能类型中的**一种**。<br>**积类型 (Product Type):** 一个值**同时包含**多种类型。 | **精确建模业务状态：** 当你想在类型系统中就保证一个变量的状态是合法且唯一的。<br>**场景示例：** 定义一个网络请求的状态，它只能是 `Loading`, `Success(data)`, `Error(message)` 三者之一，而不可能同时是 `Loading` 和 `Success`。这可以彻底消灭无效的UI状态。 |
| **2. 模式匹配 (Pattern Matching)** | 一种高级的 `switch` 语句，可以根据 ADT 的不同形态进行解构和逻辑分支，并强制进行**穷尽性检查**。 | **安全地处理 ADT：** 当你需要根据一个和类型变量的不同状态执行不同的逻辑时。<br>**场景示例：** 渲染一个网络请求的结果。通过模式匹配，编译器会强制你处理 `Loading`, `Success`, `Error` 三种情况，如果你忘记处理其中一种，代码将无法编译。 |
| **3. 函子 (Functor)** | 一个包含值的“容器” (`Context`)，并提供一个 `map` 方法，允许你用函数操作容器内的值，而无需关心容器的具体形态。 | **隔离上下文相关的操作：** 当你想对一个值进行一系列操作，但这个值本身可能被某种“上下文”包裹时。<br>**场景示例：**<br>1.  **`Maybe`/`Optional` Functor：** 处理可能为 `null` 或 `nil` 的值。你可以安全地对一个 `Maybe<User>` 对象链式调用 `.map(getAddress).map(getStreet)`，任何一步返回空，后续操作都会被跳过，不会产生空指针异常。<br>2.  **`Array` Functor：** `Array.map` 就是函子的体现，它让你能操作数组内的每个值，而无需关心数组本身。 |
| **4. 应用函子 (Applicative Functor)** | 一个加强版的函子，提供 `apply` 方法，允许将一个**容器内的函数**应用到**容器内的值**上。 | **处理多个带上下文的参数：** 当一个函数需要多个参数，而这些参数都分别被包裹在独立的容器中时。<br>**场景示例：** 一个表单有两个输入框，每个输入框的验证结果都是一个 `Validation<String>`（可能是成功值，也可能是失败信息）。你需要将这两个成功的值传递给 `createUser(name, email)` 函数。Applicative Functor 可以将 `Validation<Function>` 应用到 `Validation<String>` 上，实现这个组合。 |
| **5. 幺半群 (Monoid)** | 一个定义了**可合并**规则的类型。它包含一个**二元结合操作**和一个**单位元**。 | **提供通用的、可并行的聚合操作：** 当你需要将一个集合中的元素两两合并成一个最终结果时。<br>**场景示例：**<br>1.  **配置合并：** 多个配置文件（如默认配置、用户配置、环境配置）可以被安全地、以任意顺序合并成一个最终配置。<br>2.  **大数据处理：** 在 MapReduce 框架中，`Reduce` 阶段的合并操作必须符合幺半群规律，这样才能被分布式并行计算。 |
| **6. 单子 (Monad)** | 一个提供了 `flatMap` (或 `bind`, `chain`) 方法的容器，用于**链接依赖于前一步结果的计算**。 | **管理顺序依赖和副作用：** 这是 Monad 最核心的应用场景。<br>1.  **错误处理 (`Either` Monad)：** 链接一系列可能失败的操作。任何一步失败，整个计算链就会“短路”，直接返回错误，完美替代层层嵌套的 `if err != nil`。<br>2.  **异步编程 (`Promise`/`Future` Monad)：** 将多个异步回调串联成一个看似同步的、线性的代码流，避免“回调地狱”。<br>3.  **依赖注入/读取器 (`Reader` Monad)：** 在一个计算链中，隐式地传递共享的上下文（如配置、数据库连接），而无需在每个函数签名中都显式传递它。 |