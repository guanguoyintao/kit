
# 算法复杂度核心知识

---

## 1. 什么是算法复杂度？

算法复杂度（Algorithm Complexity）是用来衡量一个算法在计算机上执行时所需要的计算资源的一种度量。它主要分为两个维度：

*   **时间复杂度 (Time Complexity)**: 预估算法执行所需的时间。它通常关注的是算法中基本操作的执行次数，而不是实际的运行时间（因为实际时间受硬件、编程语言等多种因素影响）。
*   **空间复杂度 (Space Complexity)**: 预估算法执行所需的内存空间。它关注的是算法在运行过程中临时占用的存储空间大小。

复杂度的分析着眼于当输入数据规模`n`趋向于无穷大时，算法所需时间和空间的增长趋势。

## 2. 渐进符号：描述增长趋势的数学语言

为了精确地描述这种增长趋势，我们使用一套被称为“渐进符号” (Asymptotic Notations) 的数学工具。这些符号忽略了常数系数和低阶项，只关注增长的主导部分。

### **2.1 大O符号 (Big O Notation): 增长的上界**

*   **定义**: `f(n) = O(g(n))` 表示存在正常数 `c` 和 `n₀`，使得当 `n ≥ n₀` 时，总有 `0 ≤ f(n) ≤ c * g(n)`。
*   **通俗解释**: `f(n)` 的增长速度**不会快于** `g(n)`。它描述了算法性能的**上限**，即**最坏情况**。
*   **为什么最常用**: 在算法设计中，我们最关心的是算法在最糟糕的情况下表现如何，以确保其在任何输入下都能满足性能要求。这为我们提供了一个安全保证。
*   **示例**: 如果一个算法的运行时间是 `3n² + 5n + 10`，其时间复杂度为 `O(n²)`。

### **2.2 大Ω符号 (Big Omega Notation): 增长的下界**

*   **定义**: `f(n) = Ω(g(n))` 表示存在正常数 `c` 和 `n₀`，使得当 `n ≥ n₀` 时，总有 `f(n) ≥ c * g(n) ≥ 0`。
*   **通俗解释**: `f(n)` 的增长速度**不会慢于** `g(n)`。它描述了算法性能的**下限**，即**最优情况**。
*   **示例**: 对于插入排序，最好的情况是输入数组已经有序，此时时间复杂度为 `Ω(n)`。

### **2.3 大Θ符号 (Big Theta Notation): 精确的界**

*   **定义**: `f(n) = Θ(g(n))` 表示同时满足 `f(n) = O(g(n))` 和 `f(n) = Ω(g(n))`。
*   **通俗解释**: `f(n)` 的增长速度**等于** `g(n)` 的增长速度。它给出了算法性能的**精确范围**。
*   **示例**: 对于归并排序，无论最好还是最坏情况，其时间复杂度都是 `Θ(n log n)`。

### **2.4 小o符号 (Little o Notation): 非紧确的上界**

*   **定义**: `f(n) = o(g(n))` 表示对于**任意**正常数 `c`，都存在一个 `n₀`，使得当 `n ≥ n₀` 时，总有 `0 ≤ f(n) < c * g(n)`。
*   **通俗解释**: `f(n)` 的增长速度**远小于** `g(n)` 的增长速度。当 `n` 趋于无穷大时，`f(n)` 在 `g(n)` 面前变得微不足道。
*   **数学极限形式**: `lim (n→∞) [f(n) / g(n)] = 0`。
*   **与大O的区别**:
    *   **大O (O)** 是一个“小于或等于”（`≤`）的关系：`n² = O(n²)` 成立，`n = O(n²)` 也成立。它提供了一个上界，但不一定是紧确的。
    *   **小o (o)** 是一个严格的“小于”（`<`）的关系：`n = o(n²)` 成立，但是 `n² = o(n²)` **不成立**。它表示一个函数比另一个函数增长得**慢得多**。
*   **示例**:
    *   `2n = o(n²)`，因为当 `n` 足够大时，`n²` 的增长速度远快于 `2n`。
    *   `log n = o(n)`，对数的增长远慢于线性增长。
*   **用途**: 小o符号在算法分析中不如大O常用，但在数学分析和某些更精细的算法复杂度证明中非常有用，因为它提供了一个更强的关于函数增长关系的声明。

### **2.5 小ω符号 (Little Omega Notation): 非紧确的下界**

*   **定义**: `f(n) = ω(g(n))`，其关系与小o符号相反。
*   **通俗解释**: `f(n)` 的增长速度**远大于** `g(n)` 的增长速度。
*   **数学极限形式**: `lim (n→∞) [f(n) / g(n)] = ∞`。
*   **示例**: `n² = ω(n)`。

## 3. 复杂度的不同情况分析

对于同一个算法，输入的具体数据不同，其执行效率也可能不同。因此，我们通常会分析以下三种情况：

*   **最坏情况复杂度 (Worst-case Complexity)**: 算法在所有可能输入下，执行时间最长或所需空间最大的一种情况。这通常是我们最关心的，对应于**大O符号**。
*   **最好情况复杂度 (Best-case Complexity)**: 算法在所有可能输入下，执行时间最短或所需空间最小的一种情况。对应于**大Ω符号**。
*   **平均情况复杂度 (Average-case Complexity)**: 假设所有输入以等概率出现时，算法的期望运行时间。这种分析可能更贴近实际，但分析过程也更复杂。

## 4. 常见的时间复杂度类别

以下是常见的时间复杂度，按照效率从高到低（即耗时从少到多）排列：

*   **O(1)**: **常数阶**。执行时间不随输入规模`n`变化。例如：访问数组中某个索引的元素。
*   **O(log n)**: **对数阶**。每次操作都将问题规模减半。例如：二分查找。
*   **O(n)**: **线性阶**。执行时间与输入规模`n`成正比。例如：遍历一个数组。
*   **O(n log n)**: **线性对数阶**。常见于高效的排序算法。例如：归并排序、快速排序（平均情况）。
*   **O(n²)**: **平方阶**。通常涉及嵌套循环。例如：冒泡排序、选择排序。
*   **O(n³)**: **立方阶**。通常涉及三层嵌套循环。例如：简单的矩阵乘法。
*   **O(2ⁿ)**: **指数阶**。算法的性能随`n`的增加而急剧下降。例如：斐波那契数列的递归实现。
*   **O(n!)**: **阶乘阶**。性能极差，只能处理非常小规模的问题。例如：旅行商问题的暴力求解。

## 5. 空间复杂度分析

空间复杂度的分析方法与时间复杂度类似，但关注的是算法占用的内存空间。

*   **O(1)**: 算法所需的临时空间是固定的，不随`n`变化。
*   **O(n)**: 算法所需的空间与输入规模`n`线性相关。例如：创建一个与输入数组等大的新数组。
*   **O(n²)**: 算法所需的空间与`n`的平方成正比。例如：创建一个`n x n`的二维数组。

## 总结

| 符号 | 名称 | 关系 | 通俗解释 |
| :--- | :--- | :--- | :--- |
| **O** | 大O | `f(n) ≤ c*g(n)` | 增长**不快于** (上界) |
| **Ω** | 大Omega | `f(n) ≥ c*g(n)` | 增长**不慢于** (下界) |
| **Θ** | 大Theta | `c₁*g(n) ≤ f(n) ≤ c₂*g(n)` | 增长速度**等于** (确界) |
| **o** | 小o | `f(n) < c*g(n)` 对任意c | 增长**远慢于** (严格上界) |
| **ω** | 小omega | `f(n) > c*g(n)` 对任意c | 增长**远快于** (严格下界) |

在日常开发和算法面试中，**大O符号**是最重要和最常用的工具，因为它为我们提供了对算法性能“最坏打算”的评估，这在工程实践中至关重要。理解其他符号则能帮助我们更全面、更精确地分析算法的特性。