# 两个协程交替打印输出

Golang 中优雅地实现两个协程交替打印，是面试中常见的一道并发编程题目。以下将介绍几种优雅的实现方式，并分析其优劣，帮助你更好地理解 Go 语言的并发模型。

### 核心思想

解决这个问题的核心在于**同步**两个协程的执行顺序。你需要一种机制，确保一个协程打印完毕后，能够通知另一个协程开始打印，如此交替进行。在 Go 语言中，最常用的同步原语是**通道 (Channel)** 和**等待组 (WaitGroup)**。

### 1. 使用单个无缓冲通道（Ping-Pong 式）

这是最简洁、最符合 Go 语言风格的实现方式。通过一个无缓冲的通道，在两个协程之间来回传递信号，就像打乒乓球一样。

**代码示例:**

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	// 使用 WaitGroup 等待两个协程执行完毕
	var wg sync.WaitGroup
	wg.Add(2)

	// 创建一个无缓冲的通道用于同步
	ch := make(chan struct{})

	// 协程一：打印奇数
	go func() {
		defer wg.Done()
		for i := 1; i <= 9; i += 2 {
			fmt.Println("协程一:", i)
			// 发送信号，通知协程二可以打印了
			ch <- struct{}{}
			// 等待协程二的信号
			<-ch
		}
	}()

	// 协程二：打印偶数
	go func() {
		defer wg.Done()
		for i := 2; i <= 10; i += 2 {
			// 等待协程一的信号
			<-ch
			fmt.Println("协程二:", i)
			// 发送信号，通知协程一可以打印了
			ch <- struct{}{}
		}
	}()

	// 等待所有协程执行结束
	wg.Wait()
}
```

**优雅之处:**

*   **代码简洁**: 仅用一个通道就实现了复杂的同步逻辑。
*   **符合 Go 的哲学**: "不要通过共享内存来通信，而要通过通信来共享内存"。这里通过通道传递“执行权”的信号，而不是共享一个状态变量。
*   **易于理解**: "乒乓"模型非常直观地表达了交替执行的概念。

### 2. 使用两个通道

这种方法为每个协程分配一个“许可证”通道，逻辑更清晰，但代码稍多一些。

**代码示例:**

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	// numberChan 用于通知打印数字的协程
	numberChan := make(chan struct{}, 1) // 使用缓冲通道并预先放入一个元素，确保数字协程先开始
	// letterChan 用于通知打印字母的协程
	letterChan := make(chan struct{})

	// 协程一：打印数字
	go func() {
		defer wg.Done()
		for i := 1; i <= 5; i++ {
			// 等待打印数字的许可
			<-numberChan
			fmt.Printf("数字: %d\n", i)
			// 发送许可给字母协程
			letterChan <- struct{}{}
		}
	}()

	// 协程二：打印字母
	go func() {
		defer wg.Done()
		for i := 'A'; i <= 'E'; i++ {
			// 等待打印字母的许可
			<-letterChan
			fmt.Printf("字母: %c\n", i)
			// 发送许可给数字协程
			numberChan <- struct{}{}
		}
	}()

	// 启动第一个协程
	numberChan <- struct{}{}

	wg.Wait()
}
```

**优雅之处:**

*   **职责单一**: 每个通道的功能非常明确，一个负责通知打印数字，一个负责通知打印字母。
*   **可扩展性**: 如果有更多的协程需要按顺序执行，这种模式更容易扩展。

### 3. 使用 `sync.Mutex` 和 `sync.Cond`

对于习惯了传统多线程编程中锁和条件变量的开发者来说，这种方式也同样适用，但它在 Go 中不那么常用。

**代码示例:**

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup
	wg.Add(2)

	var mu sync.Mutex
	cond := sync.NewCond(&mu)
	// turn 用来标记当前应该由哪个协程执行
	turn := 1

	// 协程一
	go func() {
		defer wg.Done()
		for i := 1; i <= 9; i += 2 {
			mu.Lock()
			// 如果不是自己的回合，就等待
			for turn != 1 {
				cond.Wait()
			}
			fmt.Println("协程一:", i)
			// 切换回合
			turn = 2
			// 唤醒可能在等待的另一个协程
			cond.Signal()
			mu.Unlock()
		}
	}()

	// 协程二
	go func() {
		defer wg.Done()
		for i := 2; i <= 10; i += 2 {
			mu.Lock()
			// 如果不是自己的回合，就等待
			for turn != 2 {
				cond.Wait()
			}
			fmt.Println("协程二:", i)
			// 切换回合
			turn = 1
			// 唤醒可能在等待的另一个协程
			cond.Signal()
			mu.Unlock()
		}
	}()

	wg.Wait()
}
```

**优雅之处:**

*   **逻辑明确**: 对于熟悉 `Mutex` 和条件变量的开发者来说，这种状态控制的方式非常清晰。
*   **适用性广**: 在更复杂的同步场景中，条件变量能提供比通道更灵活的控制。

### 总结

| 实现方式 | 优点 | 缺点 | 推荐度 |
| :--- | :--- | :--- | :--- |
| **单个无缓冲通道** | 代码最简洁，最符合 Go 语言的并发哲学 | 对于初学者可能需要一点时间来理解其阻塞机制 | ⭐⭐⭐⭐⭐ (最推荐) |
| **两个通道** | 职责清晰，逻辑明确，易于扩展 | 代码量稍多 | ⭐⭐⭐⭐ |
| **`sync.Mutex` 和 `sync.Cond`** | 控制灵活，适用于更复杂的同步场景 | 代码相对冗长，在 Go 中对于此问题不是最地道的解法 | ⭐⭐⭐ |

在面试中，能够写出**第一种（单个无缓冲通道）**的方案通常会给面试官留下深刻的印象，因为它最能体现你对 Go 语言并发编程的理解和掌握。同时，如果能进一步阐述其他两种方案并分析它们的优劣，则更能展示你知识的广度和深度。