# 动态规划

---

## **动态规划知识点大全 (A Comprehensive Guide to Dynamic Programming)**

### **1. 什么是动态规划？**

动态规划是一种通过将复杂问题分解为更小的、重叠的子问题来解决问题的算法思想。它将每个子问题的解存储起来，以避免重复计算，从而用空间换取时间，提高效率。

**1.1 核心思想**
记住已经解决过的子问题的答案。

**1.2 适用场景**
问题可以被分解成一系列重叠的子问题，并且符合**最优子结构**性质。

**1.3 与分治法的区别**
*   **1.3.1 分治法 (Divide and Conquer)**：子问题是相互独立的（如归并排序）。
*   **1.3.2 动态规划 (DP)**：子问题是相互关联、有重叠的（如斐波那契数列）。

### **2. 动态规划的两大核心特征**

一个问题能够使用DP解决，必须具备以下两个核心特征：

**2.1 最优子结构 (Optimal Substructure)**
*   **2.1.1 定义**：一个问题的最优解包含其子问题的最优解。换句话说，我们可以通过组合子问题的最优解，来构造出原问题的最优解。
*   **2.1.2 例子**：在一个图中找最短路径，如果从A到C的最短路径经过B，那么路径中A到B的部分也一定是A到B的最短路径。

**2.2 重叠子问题 (Overlapping Subproblems)**
*   **2.2.1 定义**：在递归求解的过程中，许多相同的子问题会被计算多次。
*   **2.2.2 例子**：计算斐波那契数列 `fib(5)` 时，`fib(3)` 会被计算两次。DP通过存储 `fib(3)` 的结果，使得第二次遇到时可以直接使用，无需重新计算。

### **3. 实现动态规划的两种方式**

**3.1 自顶向下 (Top-Down) 与 记忆化 (Memoization)**
*   **3.1.1 过程**：从原问题出发，使用递归函数进行求解。如果一个子问题之前没有计算过，就计算它，并将结果存储在一个数据结构（如哈希表或数组）中。如果已经计算过，就直接返回存储的结果。
*   **3.1.2 优点**：写法直观，接近暴力递归的思路，只计算被需要的子问题。
*   **3.1.3 缺点**：函数调用有开销，递归深度过大可能导致栈溢出。

**3.2 自底向上 (Bottom-Up) 与 表格法 (Tabulation)**
*   **3.2.1 过程**：不使用递归，而是从最小的子问题开始，迭代地计算并填充一个DP表格。后续问题的解依赖于表格中已经计算出的结果。
*   **3.2.2 优点**：没有递归开销，效率通常更高。
*   **3.2.3 缺点**：需要明确状态的遍历顺序，有时会计算一些最终用不到的子问题。

### **4. 解决动态规划问题的五步法**

当你遇到一个疑似DP的问题时，可以遵循以下五个步骤来构建解决方案，这也是解决DP问题的核心框架。

**4.1 定义状态 (State)**
这是最关键也是最难的一步。你需要定义一个 `dp` 数组（或多维数组），并明确 `dp[i]` 或 `dp[i][j]` 代表什么。技巧是思考 "我要求解的原问题是什么"，然后将其推广到子问题。

**4.2 确定状态转移方程 (State Transition Equation)**
这是DP的逻辑核心。你需要找到 `dp[i]` 与 `dp[i-1]`, `dp[i-2]`... 等已经计算出的状态之间的关系。技巧是思考 `dp[i]` 是如何从之前的状态推导出来的。

**4.3 确定基础情况 (Base Cases)**
这是状态转移的起点，也是递推或迭代的终止条件。技巧是思考 `dp[0]`, `dp[1]` 等最小规模子问题的解是什么，这些值通常是显而易见的。

**4.4 确定遍历顺序 (Iteration Order)**
对于表格法，你需要确定填充DP表格的顺序，确保在计算 `dp[i]` 时，它所依赖的状态都已经被计算出来了。

**4.5 计算最终答案**
最终的答案可能直接是 `dp` 数组的最后一个元素（如 `dp[n]`），也可能是整个数组中的最大值或需要特殊计算的值。

### **5. 经典动态规划模型与问题**

掌握了以下经典模型，你就能解决大部分的DP问题。

**5.1 线性/序列DP (Linear DP)**
*   **5.1.1 特点**：状态通常定义在一维数组上，`dp[i]` 只与 `i` 之前的状态有关。
*   **5.1.2 经典问题**：斐波那契数列 / 爬楼梯、最长递增子序列 (LIS)、打家劫舍系列、最大子数组和。

**5.2 背包问题 (Knapsack Problems)**
*   **5.2.1 特点**：在一堆物品中，根据限制条件（如重量）选择物品，以达到价值最大化。
*   **5.2.2 经典模型**：
    *   **0/1背包**：每个物品只能选一次或不选。
    *   **完全背包**：每个物品可以选无限次。
    *   **多重背包**：每个物品有数量限制。

**5.3 区间DP (Interval DP)**
*   **5.3.1 特点**：`dp[i][j]` 表示区间 `[i, j]` 上的最优解，通常由更小的子区间 `dp[i][k]` 和 `dp[k+1][j]` 推导而来。
*   **5.3.2 经典问题**：矩阵链乘法、戳气球、石子合并。

**5.4 字符串DP**
*   **5.4.1 特点**：状态通常与两个或多个字符串的子串相关。
*   **5.4.2 经典问题**：最长公共子序列 (LCS)、最长公共子串、编辑距离、通配符匹配。

**5.5 状态压缩DP (State Compression DP)**
*   **5.5.1 特点**：当状态的某个维度很小（通常<=20）时，可以用一个整数的二进制位来表示这个状态。
*   **5.5.2 经典问题**：旅行商问题 (TSP)、最短哈密顿路径、棋盘覆盖问题。

**5.6 树形DP (Tree DP)**
*   **5.6.1 特点**：在树形结构上进行DP，一个节点的状态由其子节点的状态推导而来。
*   **5.6.2 经典问题**：树的最大独立集、树的直径、没有上司的舞会。

**5.7 计数DP (Counting DP)**
*   **5.7.1 特点**：问题不是求最优解，而是求“有多少种方法/方案”。状态转移方程通常是加法。
*   **5.7.2 经典问题**：路径总数、组合总和、解码方法。

### **6. DP优化技巧**

**6.1 空间优化**
*   **6.1.1 滚动数组**：如果 `dp[i]` 只依赖于前几个状态，DP数组的空间可以被压缩。例如，从 `O(N)` 优化到 `O(1)`，或从 `O(N*M)` 优化到 `O(M)`。

**6.2 数据结构优化**
*   **6.2.1 单调队列优化**：用于优化形如 `dp[i] = min(dp[j]) + val[i]` (其中 `i-k <= j < i`) 的转移方程。
*   **6.2.2 前缀和/树状数组/线段树优化**：用于快速计算某个区间的和/最值。
