# 鸡蛋掉落问题
这是一个经典的谷歌面试题，通常被称为“鸡蛋掉落问题”。问题的核心在于，在最坏的情况下，如何用最少的尝试次数来确定手机摔碎的临界楼层。

这是一个典型的动态规划问题，但我们可以用一种更直观的策略来解决。

## 比如给你两部手机，让你站在一百层楼高的地方，假设，在第 n 层手机摔下就会摔破，问你怎样用着两部手机确定这个临界层

---

### 核心思路

我们的目标是尽量减少在最坏情况下的尝试次数。

1.  **如果只有一个手机**：你别无选择，只能从第1层开始，一层一层地往上扔，直到手机摔碎。在最坏的情况下（比如临界层是第100层），你需要扔100次。

2.  **现在有两个手机**：我们可以利用第一个手机来缩小范围，然后用第二个手机进行精确查找。

### 错误的策略：二分法

一个常见的错误想法是使用二分法。比如，先把第一部手机从50楼扔下。
*   **如果碎了**：那么临界层就在1到49楼之间。你需要用第二部手机从1楼开始，一层一层地往上试，最坏情况下需要尝试49次。总共最多需要 1 + 49 = 50 次。
*   **如果没碎**：那么临界层在51到100楼之间。你再拿着第一部手机去75楼扔……

这种策略在某些情况下很好，但我们考虑的是**最坏情况**。如果临界层在49楼，你就需要尝试50次，这个数字不是最优的。

### 最优策略：减少最坏情况下的总尝试次数

我们的策略应该是，无论第一个手机在哪一层摔碎，总的尝试次数（第一个手机的尝试次数 + 第二个手机的尝试次数）都应该大致相等，并且这个值应该是最小的。

假设我们第一次在第 `x` 层扔下第一部手机：

*   **如果碎了**：临界层就在 1 到 `x-1` 层之间。我们必须用第二部手机从第1层开始，逐一测试，最坏情况下需要 `x-1` 次。总的尝试次数是 `1 + (x-1) = x` 次。
*   **如果没碎**：我们接下来应该去更高的楼层。假设我们第二次去 `x + (x-1)` 层扔。为什么是 `x-1`？因为我们希望，如果这次手机碎了，我们用第二部手机需要从 `x+1` 层开始测试，最多测试 `x-2` 次。这样，总的尝试次数就是 `2 + (x-2) = x` 次。

通过这种方式，我们确保了每次尝试，在最坏情况下的总次数都等于 `x`。

我们建立一个等式：
第一次扔的楼层：`x`
第二次扔的楼层：`x + (x-1)`
第三次扔的楼层：`x + (x-1) + (x-2)`
...
第 `k` 次扔的楼层：`x + (x-1) + (x-2) + ... + (x - k + 1)`

这个楼层总数必须大于或等于100。我们需要找到满足这个条件的最小的 `x`。

`x + (x-1) + (x-2) + ... + 1 >= 100`

这是一个等差数列求和：
`x * (x + 1) / 2 >= 100`

我们来计算一下：
*   如果 x = 10,  10 * 11 / 2 = 55 (不够)
*   如果 x = 13,  13 * 14 / 2 = 91 (不够)
*   如果 x = 14,  14 * 15 / 2 = 105 (大于100)

所以，我们选择 `x = 14`。这意味着，在最坏的情况下，我们最多需要尝试14次。

### 具体操作步骤

1.  **第一次**：去 **14楼** 扔下第一部手机。
    *   **如果碎了**：用第二部手机从1楼开始，依次测试到13楼，最多需要13次。总尝试次数最多为 1 + 13 = 14次。
    *   **如果没碎**：进入下一步。

2.  **第二次**：去 `14 + 13 =` **27楼** 扔下第一部手机。
    *   **如果碎了**：用第二部手机从15楼开始，依次测试到26楼，最多需要12次。总尝试次数最多为 2 + 12 = 14次。
    *   **如果没碎**：进入下一步。

3.  **第三次**：去 `27 + 12 =` **39楼** 扔下第一部手机。
    *   **如果碎了**：用第二部手机从28楼开始测试，最多需要11次。总尝试次数最多为 3 + 11 = 14次。
    *   **如果没碎**：继续...

4.  **以此类推**，你扔第一部手机的楼层分别是：
    *   14楼
    *   27楼 (14+13)
    *   39楼 (27+12)
    *   50楼 (39+11)
    *   60楼 (50+10)
    *   69楼 (60+9)
    *   77楼 (69+8)
    *   84楼 (77+7)
    *   90楼 (84+6)
    *   95楼 (90+5)
    *   99楼 (95+4)
    *   ...

通过这种方法，你可以保证在最多**14次**尝试之内，一定能找到那个临界楼层。

## 传统鸡蛋掉落问题

---

### 思路一：正向思维DP（求最少尝试次数）

这是最符合直觉的DP思路。

#### 1. 定义DP状态

我们要求解的是“用 `k` 个鸡蛋，在 `n` 层楼中，找到临界层所需要的**最少尝试次数**”。

所以，我们定义一个二维数组 `dp[k][n]`：
**`dp[k][n]` =  拥有 `k` 个鸡蛋，需要测试 `n` 层楼时，在最坏情况下，最少需要扔多少次。**

我们的最终目标就是求出 `dp[K][N]` 的值（比如 K个鸡蛋，N=100层楼）。

#### 2. 状态转移方程

为了求 `dp[k][n]`，我们需要做一个决策：**在 `1` 到 `n` 楼之间，选择哪一层 `x` 楼扔下第一个鸡蛋？**

当我们从 `x` 楼扔下时，有两种结果：

*   **鸡蛋碎了**：我们只剩下 `k-1` 个鸡蛋，并且问题规模缩小为在下面的 `x-1` 层楼里寻找。此时，后续需要的次数是 `dp[k-1][x-1]`。
*   **鸡蛋没碎**：我们还有 `k` 个鸡蛋，问题规模缩小为在上面的 `n-x` 层楼里寻找。此时，后续需要的次数是 `dp[k][n-x]`。

因为我们必须为**最坏情况**做准备，所以对于给定的 `x`，尝试次数是 `max(dp[k-1][x-1], dp[k][n-x])`。

我们的决策是在所有可能的 `x`（从1到n）中，选择一个能让这个“最坏情况”最小化的 `x`。

所以，状态转移方程就出来了：
**`dp[k][n] = 1 + min( max(dp[k-1][x-1], dp[k][n-x]) )`**  (其中 `1 <= x <= n`)

*   `1 + ...`：代表我们在 `x` 楼扔的这一次。
*   `min(...)`：代表我们选择最优的楼层 `x`。
*   `max(...)`：代表我们要应对最坏的结果。

#### 3. 基础情况 (Base Cases)

*   如果楼层为0 (`n=0`)，不需要扔：`dp[k][0] = 0`。
*   如果楼层为1 (`n=1`)，只需要扔1次：`dp[k][1] = 1`。
*   如果只有1个鸡蛋 (`k=1`)，只能从1楼开始一层层试：`dp[1][n] = n`。

#### 4. 求解过程

我们可以创建一个 `(K+1) x (N+1)` 的表格，根据基础情况和状态转移方程，从小到大依次填满整个表格，最后 `dp[K][N]` 就是答案。

这种解法的时间复杂度是 O(K * N^2)，可以通过二分查找优化 `x` 的选择，将复杂度降至 O(K * N * logN)。

---

### 思路二：逆向思维DP（求能测试的最大楼层数）

这种思路更加巧妙，也更高效。我们换一个角度看问题。

#### 1. 定义DP状态

我们不再直接求“最少次数”，而是求“在给定鸡蛋和次数下，最多能测试多少楼层”。

定义二维数组 `dp[k][m]`：
**`dp[k][m]` = 拥有 `k` 个鸡蛋，允许扔 `m` 次，最多能够确定地测试多少层楼。**

#### 2. 状态转移方程

假设我们有 `k` 个鸡蛋和 `m` 次机会。我们从某一层 `x` 扔下第一个鸡蛋。这次投掷消耗了1次机会，剩下 `m-1` 次。

*   **鸡蛋碎了**：我们剩下 `k-1` 个鸡蛋和 `m-1` 次机会。我们可以用这些资源去检查 `x` 下方的楼层。我们最多能检查 `dp[k-1][m-1]` 层。
*   **鸡蛋没碎**：我们剩下 `k` 个鸡蛋和 `m-1` 次机会。我们可以用这些资源去检查 `x` 上方的楼层。我们最多能检查 `dp[k][m-1]` 层。

那么，总共能确定的楼层数就是：
`下方能确定的楼层数` + `上方能确定的楼层数` + `我们扔的这一层本身`

所以，状态转移方程是：
**`dp[k][m] = dp[k-1][m-1] + dp[k][m-1] + 1`**

#### 3. 基础情况 (Base Cases)

*   如果只有1次机会 (`m=1`)，不管有多少鸡蛋，都只能测试1层楼：`dp[k][1] = 1`。
*   如果只有1个鸡蛋 (`k=1`)，有 `m` 次机会，也只能一层层试，最多测试 `m` 层：`dp[1][m] = m`。

#### 4. 求解过程

我们的目标是找到一个最小的 `m`，使得 `dp[K][m] >= N` (N=100)。

我们可以从小到大计算 `m`：
1.  计算 `m=1` 时所有 `dp[k][1]` 的值。
2.  计算 `m=2` 时所有 `dp[k][2]` 的值。
3.  ...
4.  直到找到第一个 `m`，使得 `dp[K][m]` 大于等于 `N` (例如100)。这个 `m` 就是我们要求的答案。

这种解法的时间复杂度是 O(K * N)，因为最坏情况下 `m` 和 `N` 是一个量级。

### 回到手机掉落问题 (k=2, N=100)

让我们用思路二的公式来验证一下：
`dp[2][m] = dp[1][m-1] + dp[2][m-1] + 1`

我们知道 `dp[1][m-1] = m-1` (1个鸡蛋，m-1次机会，能测m-1层)。
所以，`dp[2][m] = (m-1) + dp[2][m-1] + 1 = dp[2][m-1] + m`。

这是一个递推关系：
`dp[2][1] = 1`
`dp[2][2] = dp[2][1] + 2 = 1 + 2 = 3`
`dp[2][3] = dp[2][2] + 3 = 1 + 2 + 3 = 6`
...
`dp[2][m] = 1 + 2 + 3 + ... + m = m * (m+1) / 2`

看，我们又回到了最初的数学公式！我们要求解的就是 `m * (m+1) / 2 >= 100`，解得最小的 `m` 是 **14**。

这完美地证明了，我们最初为两部手机找到的那个巧妙的数学解法，其实是这个更通用的动态规划思想在 `k=2` 时的特例！