# 数组排序

## 排序算法汇总与分析

下面是一个包含所有关键信息的汇总表，方便您快速查阅。

| 排序算法 (Sorting Algorithm) | **稳定性 (Stability)** | **时间复杂度 (Time Complexity)** | **空间复杂度 (Space Complexity)** |
| :--- | :--- | :--- | :--- |
| | | **平均 (Average)** | **最坏 (Worst)** | **最好 (Best)** | |
| **冒泡排序 (Bubble Sort)** | **稳定 (Stable)** | O(n²) | O(n²) | O(n) | O(1) |
| **插入排序 (Insertion Sort)** | **稳定 (Stable)** | O(n²) | O(n²) | O(n) | O(1) |
| **归并排序 (Merge Sort)** | **稳定 (Stable)** | O(n log n) | O(n log n) | O(n log n) | O(n) |
| **计数排序 (Counting Sort)** | **稳定 (Stable)** | O(n + k) | O(n + k) | O(n + k) | O(n + k) |
| **基数排序 (Radix Sort)** | **稳定 (Stable)** | O(d * (n + k)) | O(d * (n + k)) | O(d * (n + k)) | O(n + k) |
| **桶排序 (Bucket Sort)** | **稳定 (Stable)** | O(n + k) | O(n²) | O(n + k) | O(n + k) |
| **选择排序 (Selection Sort)** | **不稳定 (Unstable)** | O(n²) | O(n²) | O(n²) | O(1) |
| **希尔排序 (Shell Sort)** | **不稳定 (Unstable)** | O(n log n) ~ O(n²) | O(n²) | O(n log n) | O(1) |
| **快速排序 (Quick Sort)** | **不稳定 (Unstable)** | O(n log n) | O(n²) | O(n log n) | O(log n) ~ O(n) |
| **堆排序 (Heap Sort)** | **不稳定 (Unstable)** | O(n log n) | O(n log n) | O(n log n) | O(1) |

> **复杂度注解:**
> *   **n**: 数组中元素的数量。
> *   **k**: 元素的范围大小（例如，在计数排序中是最大值和最小值的差）。
> *   **d**: 基数排序中数字的最大位数。

---

### 详细说明

#### 稳定的排序算法

这些算法的设计机制保证了相等元素的相对顺序不会被改变。

1.  **冒泡排序 (Bubble Sort)**
    *   **稳定性**：稳定。它只交换相邻的元素。如果两个元素相等，交换的条件（`arr[j] > arr[j+1]`）不成立，它们就不会被交换，因此相对顺序得以保持。
    *   **时间复杂度**：平均和最坏都是 O(n²)。最好情况是 O(n)，当数组已经有序时，只需要遍历一遍。
    *   **空间复杂度**：O(1)，是原地排序。

2.  **插入排序 (Insertion Sort)**
    *   **稳定性**：稳定。当一个元素向前插入时，它会停在第一个小于或**等于**它的元素后面。这就保证了它不会越过任何与它相等的、已经排好序的元素。
    *   **时间复杂度**：平均和最坏都是 O(n²)。最好情况是 O(n)，当数组基本有序时，效率很高。
    *   **空间复杂度**：O(1)，是原地排序。

3.  **归并排序 (Merge Sort)**
    *   **稳定性**：稳定。其稳定性关键在于 `merge` 合并两个有序子数组的步骤。当左右两个子数组的元素相等时，我们**总是优先从左边的子数组取元素**放入合并后的数组。因为左边子数组的元素在原始数组中也排在前面，所以它们的相对顺序得以保留。
    *   **时间复杂度**：无论是最好、最坏还是平均情况，都是 O(n log n)，非常稳定。
    *   **空间复杂度**：O(n)。需要一个与原数组等大的辅助数组来完成合并操作。

4.  **计数排序 (Counting Sort)**
    *   **稳定性**：稳定。为了保证稳定性，在将元素放回结果数组时，需要**从后向前**遍历原始数组。这样可以确保原始数组中靠后的相等元素，会先被放入结果数组的靠后位置，从而保持了相对顺序。
    *   **时间复杂度**：O(n + k)，其中 k 是整数的范围。它不是基于比较的排序，所以可以突破 O(n log n) 的下限。
    *   **空间复杂度**：O(n + k)，需要一个计数数组和一个临时结果数组。

5.  **基数排序 (Radix Sort)** 和 **桶排序 (Bucket Sort)**
    *   **稳定性**：它们都是稳定的，但这取决于它们**内部使用的排序算法**。通常，基数排序基于稳定的计数排序，而桶排序在对每个桶内部进行排序时，如果选用的是稳定的插入排序或归并排序，那么整体就是稳定的。

#### 不稳定的排序算法

这些算法在交换元素时，可能会跨越多个位置，从而打乱相等元素间的原始顺序。

1.  **选择排序 (Selection Sort)**
    *   **稳定性**：不稳定。它每次从未排序的部分中找到最小（或最大）的元素，然后与未排序部分的第一个元素进行交换。这个交换是“长距离”的。
    *   **例子**：`[5A, 8, 5B, 2]`。第一轮，找到最小的 `2`，将它与 `5A` 交换，数组变为 `[2, 8, 5B, 5A]`。此时，`5B` 跑到了 `5A` 的前面，稳定性被破坏。
    *   **时间复杂度**：所有情况都是 O(n²)。
    *   **空间复杂度**：O(1)，是原地排序。

2.  **希尔排序 (Shell Sort)**
    *   **稳定性**：不稳定。它是插入排序的改进版，但它在不同的步长（gap）下进行插入排序，这会导致相隔很远的元素被交换，从而可能打乱相等元素的顺序。

3.  **快速排序 (Quick Sort)**
    *   **稳定性**：不稳定。问题出在**分区（Partition）** 环节。以 Lomuto 分区方案为例，基准（pivot）通常选在末尾。一个与基准相等的、但在数组靠前位置的元素，可能会被交换到基准的左边，而另一个与基准相等的、在数组靠后位置的元素，则可能留在右边，导致顺序错乱。
    *   **时间复杂度**：平均和最好是 O(n log n)。最坏是 O(n²)，当每次选取的基准都是当前数组的最小或最大值时发生（例如，对一个已经排好序的数组进行排序）。
    *   **空间复杂度**：O(log n)。主要来自递归调用的栈深度。最坏情况下，栈深度可能达到 O(n)。

4.  **堆排序 (Heap Sort)**
    *   **稳定性**：不稳定。在构建堆（heapify）和从堆顶取出最大元素并调整堆的过程中，都会发生长距离的交换。例如，一个在数组末尾的元素（值可能与堆顶元素相等）在 `heapify` 过程中可能会被交换到树的深处，完全打乱了原始的相对顺序。
    *   **时间复杂度**：所有情况都是 O(n log n)。
    *   **空间复杂度**：O(1)，是原地排序。

## 快速排序

---

### 四种快速排序分区方案

1.  **挖坑法 (Fill-the-Pit Method)**
2.  **Hoare 分区方案 (Hoare Partition Scheme)**
3.  **双指针交换法 (Lomuto Partition Scheme)**
4.  **三路快速排序 (3-Way Quicksort)**

### 1. 挖坑法 (Fill-the-Pit Method)

这是非常容易理解的一种实现，它的核心思想是通过一个“坑”的移动来完成分区。

#### 算法思路

1.  **选定基准，挖出第一个坑**：
    *   通常选择第一个元素 `arr[low]` 作为基准值（`pivot`），并将其保存到一个临时变量中。
    *   这样，`arr[low]` 的位置就空出来了，我们称之为“坑”。

2.  **高指针（`high`）填坑**：
    *   指针 `high` 从数组右端向左移动，寻找第一个**小于** `pivot` 的元素。
    *   找到后，将该元素 `arr[high]` 移动到 `low` 指针所在的坑里 (`arr[low] = arr[high]`)。
    *   现在，`arr[high]` 的位置成为了新的坑。

3.  **低指针（`low`）填坑**：
    *   指针 `low` 从数组左端向右移动，寻找第一个**大于或等于** `pivot` 的元素。
    *   找到后，将该元素 `arr[low]` 移动到 `high` 指针所在的坑里 (`arr[high] = arr[low]`)。
    *   现在，`arr[low]` 的位置又变回了新的坑。

4.  **循环往复**：
    *   重复步骤 2 和 3，直到 `low` 和 `high` 指针相遇。

5.  **基准归位**：
    *   当指针相遇时，将之前保存的基准值 `pivot` 放入这个最终的坑中。此时，基准值左边的都比它小，右边的都比它大。

#### Go 代码实现

```go
package main

import "fmt"

// QuickSortFillPit 是主函数入口
func QuickSortFillPit(arr []int) {
	quickSortFillPit(arr, 0, len(arr)-1)
}

func quickSortFillPit(arr []int, low, high int) {
	if low < high {
		pivotIndex := fillThePitPartition(arr, low, high)
		quickSortFillPit(arr, low, pivotIndex-1)
		quickSortFillPit(arr, pivotIndex+1, high)
	}
}

// fillThePitPartition 使用挖坑法进行分区
func fillThePitPartition(arr []int, low, high int) int {
	// 1. 选定基准，挖出第一个坑
	pivot := arr[low]

	for low < high {
		// 2. 高指针从右向左，找比 pivot 小的来填坑
		for low < high && arr[high] >= pivot {
			high--
		}
		// 找到小的，填到 low 的坑里
		if low < high {
			arr[low] = arr[high]
		}

		// 3. 低指针从左向右，找比 pivot 大的来填坑
		for low < high && arr[low] <= pivot {
			low++
		}
		// 找到大的，填到 high 的坑里
		if low < high {
			arr[high] = arr[low]
		}
	}

	// 5. 基准归位
	arr[low] = pivot
	return low
}
```

### 2. Hoare 分区方案 (Hoare Partition Scheme)

这是快速排序算法的提出者 C. A. R. Hoare 本人设计的原始分区方案。

#### 算法思路

1.  **选择基准**：通常选择第一个元素 `arr[low]` 作为基准 `pivot`。

2.  **设置左右指针**：
    *   左指针 `i` 从数组左边界的**前一个位置** (`low - 1`) 开始。
    *   右指针 `j` 从数组右边界的**后一个位置** (`high + 1`) 开始。

3.  **指针相向移动**：
    *   左指针 `i` 不断向右移动 (`i++`)，直到找到一个**大于或等于** `pivot` 的元素。
    *   右指针 `j` 不断向左移动 (`j--`)，直到找到一个**小于或等于** `pivot` 的元素。

4.  **交换与判断**：
    *   如果此时 `i < j`，说明 `i` 和 `j` 分别在左右两边找到了不符合分区顺序的元素，于是交换 `arr[i]` 和 `arr[j]`。
    *   如果 `i >= j`，说明两个指针已经相遇或交错，分区过程结束。

5.  **返回分割点**：
    *   循环结束后，返回 `j` 作为分割点。
    *   **特别注意**：Hoare 方案不保证 `arr[j]` 就是基准 `pivot` 的最终位置。它只保证 `arr[low...j]` 的所有元素都小于等于 `arr[j+1...high]` 的所有元素。因此，递归的边界是 `(low, j)` 和 `(j+1, high)`。

#### Go 代码实现

```go
// QuickSortHoare 是主函数入口
func QuickSortHoare(arr []int) {
	quickSortHoare(arr, 0, len(arr)-1)
}

func quickSortHoare(arr []int, low, high int) {
	if low < high {
		// p 是分割点
		p := hoarePartition(arr, low, high)
		// 注意这里的递归边界！
		quickSortHoare(arr, low, p)
		quickSortHoare(arr, p+1, high)
	}
}

// hoarePartition 使用 Hoare 方案进行分区
func hoarePartition(arr []int, low, high int) int {
	pivot := arr[low]
	i := low - 1
	j := high + 1

	for {
		// 从左边找到第一个大于等于 pivot 的元素
		for {
			i++
			if arr[i] >= pivot {
				break
			}
		}

		// 从右边找到第一个小于等于 pivot 的元素
		for {
			j--
			if arr[j] <= pivot {
				break
			}
		}

		// 如果两个指针相遇或交错，则分区完成
		if i >= j {
			return j
		}

		// 交换元素
		arr[i], arr[j] = arr[j], arr[i]
	}
}
```

### 3. 双指针交换法 (Lomuto Partition Scheme)

这就是我们通常在教科书上看到的最经典的快排实现，通过一个“慢指针”来划分区域。

#### 算法思路

1.  **选择基准**：通常选择**最后一个元素** `arr[high]` 作为基准 `pivot`。

2.  **设置分区指针**：
    *   使用一个指针 `i`（慢指针），初始化为 `low - 1`。这个指针 `i` 的作用是标记“小于 `pivot`”区域的右边界。也就是说 `arr[low...i]` 的元素都将小于 `pivot`。

3.  **遍历与交换**：
    *   使用另一个指针 `j`（快指针）从 `low` 遍历到 `high - 1`。
    *   在遍历过程中，如果 `arr[j]` **小于或等于** `pivot`：
        *   将慢指针 `i` 向右移动一位 (`i++`)。
        *   交换 `arr[i]` 和 `arr[j]`。
    *   这个交换的意义是：将一个小于 `pivot` 的元素 (`arr[j]`) 放入“小于 `pivot`”的区域中，并扩大这个区域的边界。

4.  **基准归位**：
    *   遍历结束后，`arr[low...i]` 都是小于等于 `pivot` 的元素。此时 `i+1` 的位置就是 `pivot` 应该在的正确位置。
    *   交换 `arr[i+1]` 和 `arr[high]`（基准值），将基准值放到它的最终位置。

5.  **返回基准索引**：返回 `i+1`。

#### Go 代码实现

```go
// QuickSortSwap (Lomuto) 是主函数入口
func QuickSortSwap(arr []int) {
	quickSortSwap(arr, 0, len(arr)-1)
}

func quickSortSwap(arr []int, low, high int) {
	if low < high {
		p := lomutoPartition(arr, low, high)
		quickSortSwap(arr, low, p-1)
		quickSortSwap(arr, p+1, high)
	}
}

// lomutoPartition 使用双指针交换法 (Lomuto 方案)
func lomutoPartition(arr []int, low, high int) int {
	pivot := arr[high]
	i := low - 1 // i 是小于区域的右边界

	for j := low; j < high; j++ {
		if arr[j] <= pivot {
			i++
			arr[i], arr[j] = arr[j], arr[i]
		}
	}

	// 将基准值换到正确的位置 (i+1)
	arr[i+1], arr[high] = arr[high], arr[i+1]
	return i + 1
}
```

### 4. 三路快速排序 (3-Way Quicksort)

这是针对数组中**存在大量重复元素**场景的终极优化方案。

#### 算法思路

1.  **三向分区**：将数组分为三部分：
    *   小于 `pivot` 的部分
    *   等于 `pivot` 的部分
    *   大于 `pivot` 的部分

2.  **设置三个指针**：
    *   `lt`：指向“小于 `pivot`”区域的下一个位置。初始 `lt = low`。
    *   `i`：当前正在遍历的元素位置。初始 `i = low + 1`。
    *   `gt`：指向“大于 `pivot`”区域的前一个位置。初始 `gt = high`。
    *   `arr[low...lt-1]` 是小于 `pivot` 的部分。
    *   `arr[lt...i-1]` 是等于 `pivot` 的部分。
    *   `arr[gt+1...high]` 是大于 `pivot` 的部分。

3.  **遍历与分区**：
    *   选择 `arr[low]` 作为基准 `pivot`。
    *   当 `i <= gt` 时，循环判断 `arr[i]` 与 `pivot` 的关系：
        *   如果 `arr[i] < pivot`：交换 `arr[lt]` 和 `arr[i]`，然后 `lt` 和 `i` 都向右移动一位。
        *   如果 `arr[i] > pivot`：交换 `arr[gt]` 和 `arr[i]`，然后 `gt` 向左移动一位。（`i` 不动，因为交换过来的新 `arr[i]` 还需要被检查）。
        *   如果 `arr[i] == pivot`：`i` 直接向右移动一位，扩大“等于”区域。

4.  **递归子数组**：
    *   循环结束后，`arr[lt...gt]` 区域的元素都等于 `pivot`，它们已经就位，**无需再排序**。
    *   只需要递归地对“小于”部分 `(low, lt-1)` 和“大于”部分 `(gt+1, high)` 进行排序。

#### Go 代码实现

```go
// QuickSort3Way 是主函数入口
func QuickSort3Way(arr []int) {
	// 为了随机性，可以先打乱数组
	// rand.Shuffle(len(arr), func(i, j int) { arr[i], arr[j] = arr[j], arr[i] })
	quickSort3Way(arr, 0, len(arr)-1)
}

func quickSort3Way(arr []int, low, high int) {
	if low >= high {
		return
	}

	pivot := arr[low]
	lt := low    // 小于区域的右边界
	i := low + 1 // 当前指针
	gt := high   // 大于区域的左边界

	for i <= gt {
		if arr[i] < pivot {
			arr[lt], arr[i] = arr[i], arr[lt]
			lt++
			i++
		} else if arr[i] > pivot {
			arr[gt], arr[i] = arr[i], arr[gt]
			gt--
		} else { // arr[i] == pivot
			i++
		}
	}

	// 递归地对小于和大于区域进行排序
	quickSort3Way(arr, low, lt-1)
	quickSort3Way(arr, gt+1, high)
}

```

## 归并排序

---

归并排序是一种高效、稳定、基于比较的排序算法。它的核心思想是经典的计算机科学策略——**分治法（Divide and Conquer）**。

### 核心思想：分治法

分治法将一个复杂的大问题分解成若干个规模更小但结构相同的子问题，递归地解决这些子问题，然后将子问题的解合并，从而得到原始问题的解。

在归并排序中，这个过程被清晰地划分为两个阶段：

1.  **分解（Divide）**：持续地将一个大数组从中间点一分为二，直到每个子数组都只包含一个元素。在算法中，我们天然地认为只包含一个元素的数组是有序的。
2.  **合并（Conquer / Merge）**：从只包含单个元素的子数组开始，将相邻的两个有序子数组两两合并，形成一个更大规模的有序数组。这个合并过程会不断重复，直到所有子数组都被合并成一个完整的、有序的大数组。


### 算法实现详解

一个典型的归并排序实现包含两个关键部分：一个用于递归分解的函数，和一个用于合并有序数组的核心函数。

#### 1. 递归分解的框架 (`mergeSort`)

这个函数体现了“分解”的思想，其目标是不断地将数组切分成更小的部分，直到满足可以被直接处理的“基线条件”。

**逻辑流程：**

*   **函数定义**：通常定义一个递归函数，如 `mergeSort(arr, low, high)`，它负责对数组 `arr` 中从索引 `low` 到 `high` 的范围进行排序。
*   **基线条件（Base Case）**：递归必须有一个出口。当 `low >= high` 时，意味着当前的子数组最多只有一个元素，它本身就是有序的，因此递归停止。
*   **分解步骤**：
    1.  **找到中间点**：计算 `low` 和 `high` 之间的中间索引 `mid`。一种健壮的计算方式是 `mid := low + (high-low)/2`，它可以有效防止在 `low` 和 `high` 都非常大时可能发生的整数溢出。
    2.  **递归调用**：
        *   对左半部分进行递归排序：`mergeSort(arr, low, mid)`。
        *   对右半部分进行递归排序：`mergeSort(arr, mid+1, high)`。
*   **合并步骤**：当上述两个递归调用返回时，可以保证左半部分（`arr[low...mid]`）和右半部分（`arr[mid+1...high]`）各自都是有序的。此时，调用核心的 `merge` 函数，将这两个有序的子数组合并成一个大的有序数组。

#### 2. 核心合并操作 (`merge`)

这是归并排序算法的精髓所在，它负责将两个**已经有序**的子数组，高效地合并成一个大的有序数组。

**逻辑流程：**

1.  **准备辅助空间**：
    *   创建一个临时的辅助数组（`tmp`），其大小等于需要合并的两个子数组的总长度（即 `high - low + 1`）。
    *   这是归并排序 O(n) 空间复杂度的主要来源，因为需要额外的空间来存储合并过程中的结果。

2.  **设置指针**：
    *   初始化三个指针：
        *   `i`：指向左边子数组 `arr[low...mid]` 的起始位置 `low`。
        *   `j`：指向右边子数组 `arr[mid+1...high]` 的起始位置 `mid+1`。
        *   `k`：指向辅助数组 `tmp` 的起始位置 `0`。

3.  **比较与合并**：
    *   在一个循环中，只要 `i` 和 `j` 都没有超出它们各自子数组的范围，就进行比较：
        *   比较 `arr[i]` 和 `arr[j]` 的值。
        *   为了保证排序的**稳定性**（即相等元素的原始相对顺序不变），当 `arr[i] <= arr[j]` 时，将 `arr[i]` 的值放入 `tmp[k]`，然后将 `i` 向后移动一位。
        *   否则，将 `arr[j]` 的值放入 `tmp[k]`，然后将 `j` 向后移动一位。
        *   无论放入哪个元素，`k` 都要向后移动一位。

4.  **处理剩余元素**：
    *   当上述循环结束时，必然有一个子数组的所有元素已经被处理完毕，而另一个子数组可能还有剩余的元素。
    *   因为子数组本身是有序的，所以这些剩余的元素必然都大于（或等于）已经放入 `tmp` 的所有元素。
    *   因此，只需将这个有剩余元素的子数组中的所有元素，直接依次复制到 `tmp` 的末尾即可。

5.  **数据写回**：
    *   最后，将辅助数组 `tmp` 中存储的、已经完全排好序的元素，全部复制回原始数组 `arr` 的相应位置（从 `low` 到 `high`）。

### 归并排序的特性分析

*   **时间复杂度**：**O(n log n)**。
    *   `log n`：递归分解的过程会将数组的高度（层数）分为 `log n` 层。
    *   `n`：在每一层，`merge` 操作都需要对该层的所有元素进行一次遍历和合并，总操作数是 O(n)。
    *   这个时间复杂度在最好、最坏和平均情况下都是一样的，性能非常稳定。

*   **空间复杂度**：**O(n)**。
    *   主要开销来自于 `merge` 操作中需要一个与待排序数组同样规模的临时数组。

*   **稳定性**：**稳定**。
    *   在 `merge` 操作中，通过优先处理左边子数组中与右边子数组元素相等的元素（`<=`），可以保证相等元素的原始相对顺序不被改变。

### 总结

归并排序是一种通过递归将问题分解，再通过合并有序子序列来解决问题的经典排序算法。它的优点是时间复杂度稳定在 O(n log n)，且是一种稳定排序。其主要的缺点是需要 O(n) 的额外存储空间，这在内存受限的场景下可能是一个需要考虑的因素。